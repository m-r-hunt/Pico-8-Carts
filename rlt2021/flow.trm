global game_map, makeMap
global entities, player, getBlockingEntitiesAt
global calculateFOV
global PosSet

global fov_map, memory

fn handleKeys() {
	if (btnp(0)) {
		return {move = {-1, 0}}
	}
	if (btnp(1)) {
		return {move = {1, 0}}
	}
	if (btnp(2)) {
		return {move = {0, -1}}
	}
	if (btnp(3)) {
		return {move = {0, 1}}
	}

	return {}
}

fn blocks_fov(pos) {
	return fget(mget(pos[1], pos[2]), 1)
}

global message = ""
fn main() {
	while (true) {
		var dt = yield()
		var action = handleKeys()
		if (action.move) {
			var dx = player.x + action.move[1]
			var dy = player.y + action.move[2]
			if (!game_map:isBlocked(dx, dy)) {
				var target = getBlockingEntitiesAt(dx, dy)

				if (target) {
					message = "you kick the "..target.name.." in the nuts"
				} else {
					message = ""
					player:move(dx, dy)
					fov_map = calculateFOV(blocks_fov, {player.x, player.y}, 10)
					memory:unionWith(fov_map)
				}

				for (e in all(entities)) {
					if (e.ai) {
						e.ai:takeTurn()
					}
				}
			}
		}
	}
}

var main_thread = null
fn _init() {
	main_thread = cocreate(main)
	player.x, player.y = makeMap(entities)
	fov_map = calculateFOV(blocks_fov, {player.x, player.y}, 10)
	memory = PosSet()
	memory:unionWith(fov_map)
}

fn _update(dt) {
	assert(coresume(main_thread, dt))
}

fn _draw() {
	cls()

	camera(player.x*8 - 64, player.y*8 - 64)

	game_map:draw(player.x, player.y, memory, fov_map)

	for (e in all(entities)) {
		if (fov_map:contains(e.x, e.y)) {
			e:draw()
		}
	}

	camera()
	print(message, 0, 0, 7)
}
