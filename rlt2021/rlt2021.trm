fn new(class, ...) {
	var n = setmetatable({}, {__index = class})
	if (class.construct) {
		n:construct(...)
	}
	return n
}
fn Class(table) {
	return setmetatable(table, {__call = new})
}

var Entity = Class{
	method construct(x, y, sprite) {
		self.x = x
		self.y = y
		self.sprite = sprite
	},

	method move(dx, dy) {
		self.x += dx
		self.y += dy
	},

	method draw() {
		spr(self.sprite, self.x * 8, self.y * 8)
	},
}

var Tile = Class{
	method construct(blocked, block_sight) {
		self.blocked = blocked
		if (block_sight == null) {
			block_sight = blocked
		}
		self.block_sight = block_sight
	},
}

var GameMap = Class{

	method isBlocked(x, y) {
		return fget(mget(x, y), 0)
	},

	method draw() {
		map()
	},
}

var main_thread = null
var game_map = GameMap()
var player = Entity(8, 8, 1)
var npc = Entity(6, 8, 2)
var entities = {npc, player}

fn handleKeys() {
	if (btnp(0)) return {move = {-1, 0}}
	if (btnp(1)) return {move = {1, 0}}
	if (btnp(2)) return {move = {0, -1}}
	if (btnp(3)) return {move = {0, 1}}

	return {}
}

fn main() {
	while (true) {
		var dt = yield()
		var action = handleKeys()
		if (action.move) {
			var dx, dy = unpack(action.move)
			if (!game_map:isBlocked(player.x + dx, player.y + dy)) player:move(dx, dy)
		}
	}
}

fn _init() {
	main_thread = cocreate(main)
}

fn _update(dt) {
	assert(coresume(main_thread, dt))
}

fn _draw() {
	cls()

	game_map:draw()

	for (e in all(entities)) {
		e:draw()
	}
}
