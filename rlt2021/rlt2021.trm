fn new(class, ...) {
	var n = setmetatable({}, {__index = class})
	if (class.construct) {
		n:construct(...)
	}
	return n
}
fn Class(table) {
	return setmetatable(table, {__call = new})
}

var Entity = Class{
	method construct(x, y, sprite) {
		self.x = x
		self.y = y
		self.sprite = sprite
	},

	method move(dx, dy) {
		self.x += dx
		self.y += dy
	},

	method draw() {
		spr(self.sprite, self.x * 8, self.y * 8)
	},
}

var Tile = Class{
	method construct(blocked, block_sight) {
		self.blocked = blocked
		if (block_sight == null) {
			block_sight = blocked
		}
		self.block_sight = block_sight
	},
}

fn initializeTiles(width, height) {
	var tiles = {}
	for (x = 0, width-1) {
		tiles[x] = {}
		for (y = 0, height-1) {
			tiles[x][y] = Tile(false)
		}
	}

	tiles[4][2].blocked = true
	tiles[4][2].block_sight = true
	tiles[5][2].blocked = true
	tiles[5][2].block_sight = true
	tiles[6][2].blocked = true
	tiles[6][2].block_sight = true

	return tiles
}

var GameMap = Class{
	method construct(width, height) {
		self.width = width
		self.height = height
		self.tiles = initializeTiles(width, height)
	},

	method isBlocked(x, y) {
		return self.tiles[x][y].blocked
	},

	method draw() {
		for (x, row in pairs(self.tiles)) {
			for (y, t in pairs(row)) {
				var wall = t.block_sight

				if (wall) {
					spr(64, x * 8, y * 8)
				} else {
					spr(65, x * 8, y * 8)
				}
			}
		}
	},
}

var main_thread = null
global game_map = GameMap(16, 16)
var player = Entity(8, 8, 1)
var npc = Entity(6, 8, 2)
var entities = {npc, player}

fn handleKeys() {
	if (btnp(0)) return {move = {-1, 0}}
	if (btnp(1)) return {move = {1, 0}}
	if (btnp(2)) return {move = {0, -1}}
	if (btnp(3)) return {move = {0, 1}}

	return {}
}

fn main() {
	while (true) {
		var dt = yield()
		var action = handleKeys()
		if (action.move) {
			var dx, dy = unpack(action.move)
			if (!game_map:isBlocked(player.x + dx, player.y + dy)) player:move(dx, dy)
		}
	}
}

fn _init() {
	main_thread = cocreate(main)
}

fn _update(dt) {
	assert(coresume(main_thread, dt))
}

fn _draw() {
	cls()

	game_map:draw()

	for (e in all(entities)) {
		e:draw()
	}
}
